# -*- coding: utf-8 -*-
"""day8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lvp68hfLJzQE0eQrqCoYdZxMcywTuCbw
"""

import math
f = open("input8.txt", "r")
count = 1000 # how many times we want to find the lowest distance


def handle_next_connection(dist_map, circuits, mindists):
  current = mindists.pop(0)
  connected_points = dist_map[current]
  current_circuit = None
  circuit_index = None

  circuit0 = None
  circuit1 = None
  index1 = None

  # find if current points exist in the circuits
  for i in range(0, len(circuits)):
    if connected_points[0] in circuits[i]:
      circuit0 = circuits[i]
    if connected_points[1] in circuits[i]:
      circuit1 = circuits[i]
      index1 = i

  if circuit0 is not None and circuit1 is not None:
    # if both points already exist in circuits:
    if circuit0 != circuit1:
      # if points exist in separate circuits, combine them and remove one
      circuit0.update(circuit1)
      circuits.pop(index1)
    current_circuit = circuit0
  elif not circuit0 and not circuit1:
    # if neither points exist in circuits, create a new circuit
    current_circuit = set()
    circuits.append(current_circuit)
  else:
    # find the circuit that exists if only 1 point is in a circuit
    if not circuit0:
      current_circuit = circuit1
    else:
      current_circuit = circuit0

  current_circuit.add(connected_points[0])
  current_circuit.add(connected_points[1])

  return (connected_points[0], connected_points[1])


pointlist = [] # list of 3d points
dist_map = {} # map of distance to points
circuits = [] # list of lists containing points in a circuit

for i in f:
  coordinate = tuple([int(item) for item in i.strip().split(',')])
  pointlist.append(coordinate)


# part 1

# find ALL distances and store them in a map with the distance as the key
#  and the 2 points in a tuple as a value
for i in range(0, len(pointlist)):
  for j in range(i+1, len(pointlist)):
    dist = math.dist(pointlist[i], pointlist[j]) # euclidean distance
    if dist in dist_map:
      print("WHAT??") # I ain't handling this
    dist_map[dist] = (pointlist[i], pointlist[j])

# get all distances sorted from lowest to highest
mindists = list(dist_map.keys())
mindists.sort()

# handle the next X amount of minimum distances
while count >= 0:
  count -= 1
  handle_next_connection(dist_map, circuits, mindists)

# get all circuit sizes and sort by minimum distance
circuit_sizes = []
for i in circuits:
  circuit_sizes.append(len(i))
circuit_sizes.sort()

# part 1 solution
result = circuit_sizes[-1] * circuit_sizes[-2] * circuit_sizes[-3]


# part 2

# continue the same thing as part 1, but stop when requirement is reached
last_circuit_join = None
while len(mindists) > 0:
  joined_points = handle_next_connection(dist_map, circuits, mindists)
  if len(circuits) == 1:
    if len(circuits[0]) == len(pointlist):
      last_circuit_join = joined_points
      break;

# part 2 solution
result2 = last_circuit_join[0][0] * last_circuit_join[1][0]

print(result) # part 1 answer
print(result2) # part 2 answer